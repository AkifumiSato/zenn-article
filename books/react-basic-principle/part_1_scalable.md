---
title: "スケーラビリティ"
---

## 要約

Reactは、[facebook.com](https://www.facebook.com/)をはじめとしたMetaが保有する大規模プロダクト開発を支える技術基盤として開発されたため、**スケーラブル**であることを非常に重視しています。

## 背景

Metaは2004年の創業当初から急速に拡大を続け、早々に世界有数の大企業となりました。代表的なプロダクトであるfacebook.comは、当初は学生間交流を目的に開発されたSNSでしたが、今や利用者は数十億人規模に達しています。

この急速な拡大に伴い、様々なシステム課題が幾度となく発生したであろうことは想像に難くありません。これはインフラだけでなく、アプリケーションのスケールにおいても同様です。事実、2013年頃のfacebook.comは、大規模化し複雑なフロントエンド実装によってさまざまな課題を抱えていました。

これらの課題を解決し、一貫した設計秩序をもたらすために開発されたフレームワークが**React**です。

:::message
より詳細な歴史的経緯については、[Reactチームが見てる世界、Reactユーザーが見てる世界](https://zenn.dev/akfm/articles/react-team-vision)を参照ください。
:::

## 哲学

Reactは大規模なフロントエンド開発に耐えうるフレームワーク^[当初ReactはUIライブラリと呼称され、フレームワークとは呼ばれていませんでした。]として開発されたため、**スケーラブル**であることを非常に重視しています。以下は[公式ドキュメント](https://ja.react.dev/)の引用です。

> 独りで開発していても、数千の開発者と共同開発していても、Reactの開発体験は同じです。個人、チーム、大規模な組織によって書かれさまざまなコンポーネントを、シームレスに組み合わせながら開発できる。それがReactの設計理念です。

これこそが、Reactの**最も重要で基本的な哲学**です。

### 長期的な安定性

Reactの考えるスケーラブルには、長期的な安定性も含まれます。以下は[バージョニングポリシー](https://ja.react.dev/community/versioning-policy#commitment-to-stability)の引用です。

> 100万人以上の開発者がReactを使用しており、合わせれば何百万ものコンポーネントをメンテしています。Facebookのコードベースだけでも、Reactのコンポーネントは 50,000個以上存在します。だからこそ私たちは、新バージョンのReactへのアップグレードをできるだけ簡単にする必要があるのです。

複雑な対応や大きな工数を要するような破壊的変更は、開発元であるMeta自身を苦めることになることが示唆されています。つまり、Reactチームは安易に破壊的変更を行うことはできません。どうしても破壊的変更が行われる場合には、codemod^[codemodとは、コードの修正やリファクタリングを自動で行うためのツールを指します。]や代替ライブラリの提供など、何かしらアップグレードを容易にするための手段が提供される可能性が高いと考えられます。

Reactの開発元と最大の利用者が同一企業だからこそ、長期的な安定性に関しては一定の信頼がおけると筆者は考えます。

### 大規模プロダクトによるテストとリリース

[公式ドキュメントTop](https://ja.react.dev/)では、テストについても言及されています。

> すべてのコミットは10億人以上のユーザによるビジネスクリティカルな環境においてテストされます。Metaにある10万以上のReactコンポーネントが、すべての移行戦略の検証を支援します。

Reactは、facebook.comをはじめとした大規模プロダクトでアップグレードの検証試験を行ったのちに、リリースされます。そのため、新規リリースに関する安定性もかなり高いものと考えられます。

## トレードオフ

### バンドルサイズ

Reactは高いパフォーマンスも追求していますが、優先順位として最も高いのはスケーラブルであることです。そのため、[Svelte](https://svelte.jp/)のようなバンドルサイズを極小化するフレームワークなどと比較すると、バンドルサイズはトレードオフになりがちです。

### React Server Componentsへの移行

前述の通り、Reactは高い後方互換性や移行手段を提供していますが、**React Server Components**は全く新しいコンセプトで既存に対する変更ではないため、既存プロダクトで採用するにはメタフレームワークの乗り換えなど、高い移行コストを伴います。
