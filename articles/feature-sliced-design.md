---
title: "feature sliced design - 予測可能でスケーラブルなフロントエンドアーキテクチャを目指して"
emoji: "📝"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react", "vue"]
published: false
---

## feature sliced designとは

[**feature sliced design**](https://feature-sliced.design/)（以下FSD）とは、フロントエンドのディレクトリ設計方法の1つです。公式には「Architectural methodology for frontend projects(フロントエンドのアーキテクチャ方法論)」とされています。

FSDは以下のようなLayers・Slices・Segmentsといった3つの概念が登場し、以下のような構成になります。

![schema](/images/feature-sliced-design/schema.png)

FSDは主に予測可能なスコープとスケーラブルな設計を目指しています。プロジェクトがスケールするにつれて発生するよくある問題、例えば増えすぎたコンポーネントによる複雑な依存関係や名前空間の衝突などの防止に役立つ可能性があります。また、FSDはこの構成の不完全さについても言及しており、小規模すぎる場合にはデメリットの方が上回ってしまう可能性があること、そして大規模な場合にはFSDをベースに拡張するなどする必要性があることを強調しています。FSDは非常によく研究されており、段階的導入も可能なので、一定規模で複雑性が高くなったプロジェクトやそれが見込まれるプロジェクトにおいては一考の価値があると思います。

本稿は、FSDのv2について筆者なりにポイントをまとめたものになります。

:::message
筆者はFSDはまだ学んでいる途中なので、加筆修正する可能性があります。また、記事の内容に誤りがあった場合はご指摘ください。
:::

## 目的と前提

https://feature-sliced.design/docs/about/motivation

FSDの最大の目的は**開発を促進しコストを下げる**ことです。この目的を達成するために、FSDでは以下の価値観を持って問題解決に取り組んでいます。

### 設計原則やプロセスだけでは不十分

SOLID・KISS・YAGNIなどの設計原則は非常に重要ですが、アーキテクチャに対する具体的な回答としては不十分です。そして全ての人がそれらを理解しているわけではありません。アーキテクチャについてチームに説明するのは簡単である必要があります。

同様に、ドキュメント・テストなどのプロセス的アプローチも同様に、形骸化・新規参画者の高い学習コストなどいくつかの問題を引き起こします。学習が不十分な状態だと、さらに別な問題を引き起こします。

### FSDはプロジェクト知識の学習にこそ重きをおく

FSDによると、開発時の知識は以下の3つに分けられます。

| name | detail | e.g. |
|------| -- | ---- |
| **基礎知識** | 実質的に時代とともに変化しない知識。 | アルゴリズム、コンピュータサイエンス |
| **技術スタック** | プロジェクトで使用される一連の技術ソリューションに関する知識。 | プログラミング言語、フレームワーク、ライブラリ |
| **プロジェクト知識** | 現在のプロジェクトの枠組みの中でのみ適用可能な知識。 | ビジネスドメインの知識、事業やクライアントの価値観 |

FSDは、開発者はプロジェクト知識の学習にこそ時間を割くべきと考えており、その他の知識については必要最低限の学習と流用が可能なように設計を試みています。

## コンセプト

https://feature-sliced.design/docs/concepts

FSDは目的達成のために多くのコンセプトを掲げています。FSDは現実によく起きる問題の多くと向き合っているため、細かいものや公式が執筆途中のものも含めるコンセプトの説明が非常に長くなってしまうので、ここではいくつかピックアップして紹介します。

FSDはこれらを「コンセプト」と読んでますが、これらはFSDに対する要件でもあります。

### アーキテクチャ

FSDは以下の3つをアーキテクチャ要件として掲げています。

- **明示性**
  - プロジェクトとそのアーキテクチャを習得し、チームに説明するのは簡単でなければなりません
  - 明示的な副作用と抽象化間の接続が必要です
  - 優れたアーキテクチャーには、異質な抽象化とルールが多すぎてはなりません
- **コントロール**
  - 機能の導入をスピードアップする必要があります
  - コードの拡張、変更、削除が容易であること
- **適応性**
  - フレームワークやプラットフォームに依存してはいけません
  - 開発の並行化の可能性により、プロジェクトとチームを簡単にスケーリングできる必要があります
  - 変化する要件や状況に簡単に適応できる必要があります

### ニーズ主導

FSDはfeatures/processes/entitiesの作成方法を示す必要があります。

### クロスコミュニケーション

- モジュールは低カップリングに結合され、影響は予測可能・把握可能であること
- モジュールは低結合・高凝集であること(以下図の右下)
- 循環依存は排除されるべき

![low-coupling](/images/feature-sliced-design/low-coupling.png)

### public API

public APIとして`index.ts`(.tsとしていますが.jsなどでも同様)でre exportしているもののみが外部(他レイヤーのモジュール)から利用することが可能です。これにより、モジュールと外部の契約が`index.ts`集約されます。

これにより、モジュールの内部構造のリファクタは外部に影響せず安全に行うことができ、逆に破壊的変更は影響範囲の特定を容易にします。



## memo

- 設計概要
  - Layers・Slices・Segments
  - 依存関係のルール
    - https://feature-sliced.design/docs/concepts/app-splitting#layers-order
  - 公開ルール
    - https://feature-sliced.design/docs/concepts/public-api#1-access-control
- 各Layers
- Slices（ドメイン）
- Segments
- 導入
- 参考

https://profy.dev/article/react-folder-structure
https://feature-sliced.design/docs/get-started/quick-start
